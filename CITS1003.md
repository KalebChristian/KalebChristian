<div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh;">

  <h2>CITS1003 Project Report</h2>

  <p>Student ID: [Student ID]</p>
  <p>Student Name: [First and Surname]</p>

</div>

# Part 1 - Crypto

## Meowlleable RSA

### Step 1

I opened the provided files challenge.py and solve_template.py and searched for the values the challenge gave. The template and comments show the decrypted integer m and a value x. The file explicitly shows the relation used to build m:

```text
m = (flag + 2025) * x**2
x = 1337
# m is the large integer provided by the challenge
```

Why this matters: there is no modular wraparound here. m is a plain integer equal to (flag + 2025) times x squared. That means standard integer arithmetic will recover flag.

### Step 2

Rearrange the formula to isolate flag and choose the right operations.
Math:

```text
m = (flag + 2025) * x**2
=> flag + 2025 = m / x**2
=> flag = (m // (x**2)) - 2025
```

Why integer division //: m and x are integers and x**2 divides m exactly. Using // avoids floating point rounding and returns an integer.

### Step 3

Implement and run the minimal script. I used the exact values from the template and converted the resulting integer to bytes.

Script (while i could have just pasted into the provided template at line 23, I chose to instead save it into a new python file):

```python
from Crypto.Util.number import long_to_bytes

x = 1337
m = 75867975262137437190884697927628570501483722308586360649088491747991230253660794320983243053702

# line completed
flag_int = (m // (x**2)) - 2025

# convert to bytes and print
print(long_to_bytes(flag_int).decode())
```

Command I ran:

```bash
python3 solve.py
```

What this does, plainly:

* Divide m by x squared to undo the multiplication.
* Subtract 2025 to undo the addition.
* Convert the integer to bytes and decode to UTF-8 to reveal the flag.

### Result

![Terminal showing command and flag](Pictures/Terminal.png)

* Paste the plain-text flag immediately under the screenshot.

Flag captured (copy-paste into report and verify with your screenshot):

```bash
UWA{y0u_br0k3_mY_R54_3nCryP7i0n_:(((}
```

Also include the exact line added to solve_template.py (line 23):

```python
flag_int = (m // (x**2)) - 2025
```

### Step 5

Short mitigation (two lines)
What this shows: deterministic arithmetic applied after decryption leaks the original message.
Fix: do not rely on reversible transforms around secret plaintext. Use authenticated encryption or avoid exposing raw decrypted integers.

### Quick checklist for this section

* [ ] Paste terminal screenshot with command and printed flag.
* [ ] Include the plain-text flag as shown above.
* [ ] Note which file and line you edited (solve_template.py, line 23).
* [ ] Keep this section inside the provided CITS1003 template and under 30 pages total.

# Part 2 - Forensics

## The Cats Have Docked In

### Step 1

I pulled the provided Docker image and prepared to inspect it for artifacts that could recover the encrypted flag.

```bash
sudo docker pull jsun1590/fluffy-gang:latest
```

Why this matters: the ransomware was executed from a Docker image; Docker images are layered and earlier layers can contain files that were later deleted (such as private keys). Pulling the image gives access to those layers for offline inspection.

### Step 2

I inspected the image history and layer metadata to find which layer created the RSA private key and which layer deleted it.

```bash
docker history --no-trunc jsun1590/fluffy-gang:latest
docker inspect jsun1590/fluffy-gang:latest --format '{{json .RootFS.Layers}}' | python -m json.tool
```

What I found: the image created `ransomkey.pem` in an early layer and deleted it later. The layer containing the private key was identified as:

```text
sha256:66dab87c595eaa1232c5ff284376308292f621952850b629da2708169758beaf
```

Why this matters: extracting that specific layer yields the private key file that was deleted in subsequent layers.

### Step 3

I saved the Docker image to a tar archive and extracted the layer blob corresponding to the identified SHA256 layer.

```bash
docker save jsun1590/fluffy-gang:latest -o fluffy-gang-ransom.tar
mkdir -p /tmp/fluffy-extract /tmp/fluffy-layer
tar -C /tmp/fluffy-extract -xvf fluffy-gang-ransom.tar
tar -C /tmp/fluffy-layer -xvf /tmp/fluffy-extract/blobs/sha256/66dab87c595eaa1232c5ff284376308292f621952850b629da2708169758beaf
```

Result (example output):

```text
etc/
not-a-malware/
not-a-malware/ransomkey.pem
```

Why this matters: the extracted layer contains `not-a-malware/ransomkey.pem`, the RSA private key we need to decrypt `flag.enc`.

### Step 4

I copied the recovered private key to a safe local directory, restricted its permissions, and validated it with OpenSSL.

```bash
mkdir -p ~/fluffy_key
cp /tmp/fluffy-layer/not-a-malware/ransomkey.pem ~/fluffy_key/ransomkey.pem
chmod 600 ~/fluffy_key/ransomkey.pem
openssl rsa -in ~/fluffy_key/ransomkey.pem -check -noout
```

Validation output:

```text
RSA key ok
```

Why this matters: confirming the key is a valid RSA private key ensures it can be used for decryption.

### Step 5

I located the encrypted flag file and decrypted it using OpenSSL with PKCS#1 v1.5 padding.

```bash
# Example path where flag.enc was located in my environment
openssl pkeyutl -decrypt -inkey ~/fluffy_key/ransomkey.pem \
  -in ~/Downloads/flag.enc -pkeyopt rsa_padding_mode:pkcs1 \
  -out ~/Downloads/flag.txt

cat ~/Downloads/flag.txt
```

Result:

```bash
UWA{bu7_1_d3L3t3D_tH3_3nCryPt10n_k3Y???/1!}
```

Why this matters: recovering the private key from an earlier Docker layer allowed successful decryption of the ransomware output.

### Step 6

Short analysis (two lines)

* Docker image layers can contain sensitive artifacts even if later layers delete them; forensic examination of image layers can recover deleted files.
* Mitigation: do not store long-lived secrets inside build artifacts or images; use ephemeral keys from secure secret stores and rotate/delete with provable erasure.

### Evidence

* Include a terminal screenshot showing:

  * the `docker inspect` layers output
  * the `tar` extraction listing `not-a-malware/ransomkey.pem`
  * the `openssl pkeyutl` decryption and printed flag

Caption the screenshot with date/time and working directory.

#### Flag Found

```bash
UWA{bu7_1_d3L3t3D_tH3_3nCryPt10n_k3Y???/1!}
```

# Part 3 - Linux and Networking

## Emu Hack #4 - Git Gud or GTFO Bin

### Step 1

A clear, and detailed description.

### Step 2

### Step X

#### Flag Found

```bash
UWA{xxxxxxxxxx}
```

# Part 4 - Vulnerabilities

## Emu Apothecary

### Step 1

A clear, and detailed description.

### Step 2

### Step X

#### Flag Found

```bash
UWA{xxxxxxxxxx}
```
